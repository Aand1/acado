/**************************************************************************************************
 *
 * Author: Gianluca Frison, giaf (at) dtu.dk
 *
 **************************************************************************************************/

#include <stdio.h>
#include <stdlib.h>

/* HPMPC configuration */
#include "hpmpc/target.h"
#include "hpmpc/block_size.h"
#include "hpmpc/aux_d.h"
#include "hpmpc/mpc_solvers.h"

// problem size (states, inputs, horizon)
#define NX ACADO_NX
#define NU ACADO_NU
#define NN ACADO_N

// compound problem sizes
#define NZ NX+NU+1
#define PNZ D_MR*((NZ+D_MR-NU%D_MR+D_MR-1)/D_MR)
#define SPNZ S_MR*((NZ+S_MR-NU%S_MR+S_MR-1)/S_MR)

// number of inequality constraints
#define NB NU+NX

// ip method: 1 primal-dual, 2 predictor-corrector primal-dual
#define IP 1

// warm-start with user-provided solution (otherwise initialize x and u with 0 or something feasible)
#define WARM_START @WARM_START@

// number of iterations of IP method
#define K_MAX @MAX_ITER@

// tolerance in the duality measure
#define TOL 1e-4

// single or double precision: 0 - double, 1 - single
#define prec @PRECISION@

// Debug flag
#define PC_DEBUG @PRINT_LEVEL@

int acado_hpmpc_ip_wrapper(	unsigned N, unsigned nx, unsigned nu, double* A, double* B,
                            double* b, double* Q, double* Qf, double* S, double* R, double* q,
                            double* qf, double* r, double* lb, double* ub, double* x, double* u,
                            int* nIt
                          )
{
#if prec == 0

	/*** DOUBLE PRECISION ***/

	int k_max = K_MAX; // maximum number of iterations in the IP method
	double tol = TOL; // tolerance in the duality measure
	static double sigma_par[] = {0.4, 0.1, 0.001}; // control primal-dual IP behaviour
	static double stat[5*K_MAX]; // statistics from the IP routine
	static double work0[8 + (NN+1)*PNZ*PNZ + NN*PNZ*PNZ + 5*(NN+1)*PNZ + (NN+1)*2*PNZ + 3*((NN+1)*(PNZ*PNZ+PNZ+4*2*NB)+2*PNZ*PNZ)];
	int warm_start = WARM_START;
	int compute_mult = 1; // compute multipliers

	int info = 0;

	int i, ii, jj, ll;

	const int bs = d_get_mr();
	/*		const int sbs = s_get_mr(); */

	int nz = nx + nu + 1;
	int pnz = bs * ((nz + bs - nu % bs + bs - 1) / bs);

	int nb = nu + nx; // number of box constraints

	/* align work space */
	size_t align = 64;
	size_t addr = (size_t) work0;
	size_t offset = addr % 64;
	double *work = work0 + offset / 8;

	/* array or pointers */
	double *(hpBAbt[N]);
	double *(hpQ[N + 1]);
	double *(hux[N + 1]);
	double *(hlb[N + 1]);
	double *(hub[N + 1]);
	double *(hpi[N + 1]);
	double *(hlam[N + 1]);
	double *(ht[N + 1]);

	double *ptr = work;
	for (ii = 0; ii < N; ii++)
	{
		hpBAbt[ii] = ptr;
		ptr += pnz * pnz;
	}

	for (ii = 0; ii < N; ii++) // time variant and copied again internally in the IP !!!
	{
		hpQ[ii] = ptr;
		ptr += pnz * pnz;
	}
	hpQ[N] = ptr;
	ptr += pnz * pnz;

	for (ii = 0; ii <= N; ii++)
	{
		hux[ii] = ptr;
		ptr += pnz;
	}

	for (ii = 0; ii <= N; ii++) // time Variant box constraints
	{
		hlb[ii] = ptr;
		ptr += pnz; //nb; // for alignment of ptr
	}
	for (ii = 0; ii <= N; ii++) // time Variant box constraints
	{
		hub[ii] = ptr;
		ptr += pnz; //nb; // for alignment of ptr
	}
	for (ii = 0; ii <= N; ii++) // time Variant box constraints
	{
		hpi[ii] = ptr;
		ptr += pnz; // for alignment of ptr
	}
	for (ii = 0; ii <= N; ii++) // time Variant box constraints
	{
		hlam[ii] = ptr;
		ptr += 2*pnz; //nb; // for alignment of ptr
	}
	for (ii = 0; ii <= N; ii++) // time Variant box constraints
	{
		ht[ii] = ptr;
		ptr += 2*pnz; //nb; // for alignment of ptr
	}

	/* pack matrices 	*/

	// dynamic system
	for(ii = 0; ii < N; ii++)
	{
		d_cvt_mat2pmat(nu, nx, 0, bs, B+ii*nu*nx, nu, hpBAbt[ii], pnz);
		d_cvt_mat2pmat(nx, nx, nu, bs, A+ii*nx*nx, nx, hpBAbt[ii]+nu/bs*pnz*bs+nu%bs, pnz);
		for (jj = 0; jj<nx; jj++)
			hpBAbt[ii][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+jj*bs] = b[ii*nx+jj];
	}

	// cost function
	for(jj = 0; jj < N; jj++)
	{
		d_cvt_mat2pmat(nu, nu, 0, bs, R+jj*nu*nu, nu, hpQ[jj], pnz);
		d_cvt_mat2pmat(nx, nu, nu, bs, S+jj*nx*nu, nx, hpQ[jj]+nu/bs*pnz*bs+nu%bs, pnz);
		d_cvt_mat2pmat(nx, nx, nu, bs, Q+jj*nx*nx, nx, hpQ[jj]+nu/bs*pnz*bs+nu%bs+nu*bs, pnz);
		for(ii = 0; ii<nu; ii++)
			hpQ[jj][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+ii*bs] = r[ii+jj*nu];
		for(ii = 0; ii<nx; ii++)
			hpQ[jj][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+(nu+ii)*bs] = q[ii+nx*jj];
		hpQ[jj][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+(nx+nu)*bs] = 1e35;
	}

	for(jj=0; jj<nu; jj++)
		for(ii=0; ii<nz; ii+=bs)
			for(i=0; i<bs; i++)
				hpQ[N][ii*pnz+i+jj*bs] = 0.0;
	for(jj=0; jj<nu; jj++)
		hpQ[N][jj/bs*pnz*bs+jj%bs+jj*bs] = 1.0;
	d_cvt_mat2pmat(nx, nx, nu, bs, Q, nx, hpQ[N]+nu/bs*pnz*bs+nu%bs+nu*bs, pnz);
	for(jj=0; jj<nx; jj++)
		hpQ[N][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+(nu+jj)*bs] = q[jj];
	hpQ[N][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+(nx+nu)*bs] = 1e35;
	
	// input constraints
	for (jj = 0; jj < N; jj++)
	{
		for (ii = 0; ii < nu; ii++)
		{
			hlb[jj][ii] = lb[ii + nu * jj]; //if(hlb[jj][ii]<-1e2) hlb[jj][ii] = -1e2;
			hub[jj][ii] = ub[ii + nu * jj]; //if(hub[jj][ii]>1e2) hub[jj][ii] = 1e2;
		}
	}

	// state constraints
	for (jj = 0; jj < N; jj++)
	{
		for (ii = 0; ii < nx; ii++)
		{
			hlb[jj + 1][nu + ii] = lb[N * nu + ii + nx * jj]; //if(hlb[jj+1][ii]<-1e2) hlb[jj+1][ii] = -1e2;
			hub[jj + 1][nu + ii] = ub[N * nu + ii + nx * jj]; //if(hub[jj+1][ii]>1e2) hub[jj+1][ii] = 1e2;
		}
	}

	// initial guess
	for (jj = 0; jj < N; jj++)
		for (ii = 0; ii < nu; ii++)
			hux[jj][ii] = u[ii + nu * jj];

	for (jj = 0; jj <= N; jj++)
		for (ii = 0; ii < nx; ii++)
			hux[0][nu + ii] = x[ii];

	// call the IP solver
#if IP == 1
		d_ip_box(nIt, k_max, tol, warm_start, sigma_par, stat, nx, nu, N, nb, hpBAbt, hpQ, hlb, hub, hux, compute_mult, hpi, hlam, ht, ptr, &info);
#else
		d_ip2_box(nIt, k_max, tol, warm_start, sigma_par, stat, nx, nu, N, nb, hpBAbt, hpQ, hlb, hub, hux, compute_mult, hpi, hlam, ht, ptr, &info);
#endif /* IP */

	if(info != 0)
		return 1;
	
	// copy back inputs and states
	for (jj = 0; jj < N; jj++)
		for (ii = 0; ii < nu; ii++)
			u[ii + nu * jj] = hux[jj][ii];

	for (jj = 1; jj <= N; jj++)
		for (ii = 0; ii < nx; ii++)
			x[ii + nx * jj] = hux[jj][nu + ii];

#elif prec == 1

	/*** SINGLE PRECISION ***/

	int k_max = K_MAX; // maximum number of iterations in the IP method
	float tol = TOL; // tolerance in the duality measure
	static float sigma_par[] = {0.4, 0.1, 0.001}; // control primal-dual IP behaviour
	static float stat[5*K_MAX]; // statistics from the IP routine
	static float work0[8 + (NN+1)*PNZ*PNZ + NN*PNZ*PNZ + 5*(NN+1)*PNZ + (NN+1)*2*PNZ + 3*((NN+1)*(PNZ*PNZ+PNZ+4*2*NB)+2*PNZ*PNZ)];
	int warm_start = WARM_START;
	int compute_mult = 1; // compute multipliers

	int info = 0;

	int i, ii, jj, ll;

	const int bs = s_get_mr();

	int nz = nx + nu + 1;
	int pnz = bs * ((nz + bs - nu % bs + bs - 1) / bs);

	int nb = nu + nx; // number of box constraints

	/* align work space */
	size_t align = 64;
	size_t addr = (size_t) work0;
	size_t offset = addr % 64;
	float *work = work0 + offset / 4;

	/* array or pointers */
	float *(hpBAbt[N]);
	float *(hpQ[N + 1]);
	float *(hux[N + 1]);
	float *(hlb[N + 1]);
	float *(hub[N + 1]);
	float *(hpi[N + 1]);
	float *(hlam[N + 1]);
	float *(ht[N + 1]);

	float *ptr = work;
	for (ii = 0; ii < N; ii++)
	{
		hpBAbt[ii] = ptr;
		ptr += pnz * pnz;
	}

	for (ii = 0; ii < N; ii++) // time variant and copied again internally in the IP !!!
	{
		hpQ[ii] = ptr;
		ptr += pnz * pnz;
	}
	hpQ[N] = ptr;
	ptr += pnz * pnz;

	for (ii = 0; ii <= N; ii++)
	{
		hux[ii] = ptr;
		ptr += pnz;
	}

	for (ii = 0; ii <= N; ii++) // time Variant box constraints
	{
		hlb[ii] = ptr;
		ptr += pnz; //nb; // for alignment of ptr
	}
	for (ii = 0; ii <= N; ii++) // time Variant box constraints
	{
		hub[ii] = ptr;
		ptr += pnz; //nb; // for alignment of ptr
	}
	for (ii = 0; ii <= N; ii++) // time Variant box constraints
	{
		hpi[ii] = ptr;
		ptr += pnz; // for alignment of ptr
	}
	for (ii = 0; ii <= N; ii++) // time Variant box constraints
	{
		hlam[ii] = ptr;
		ptr += 2*pnz; //nb; // for alignment of ptr
	}
	for (ii = 0; ii <= N; ii++) // time Variant box constraints
	{
		ht[ii] = ptr;
		ptr += 2*pnz; //nb; // for alignment of ptr
	}

	/* pack matrices 	*/

	// dynamic system
	for(ii = 0; ii < N; ii++)
	{
		cvt_d2s_mat2pmat(nu, nx, 0, bs, B+ii*nu*nx, nu, hpBAbt[ii], pnz);
		cvt_d2s_mat2pmat(nx, nx, nu, bs, A+ii*nx*nx, nx, hpBAbt[ii]+nu/bs*pnz*bs + nu%bs, pnz);
		for (jj = 0; jj < nx; jj++)
			hpBAbt[ii][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+jj*bs] = (float) b[ii*nx+jj];
	}

	// cost function
	for(jj = 0; jj < N; jj++)
	{
		cvt_d2s_mat2pmat(nu, nu, 0, bs, R+jj*nu*nu, nu, hpQ[jj], pnz);
		cvt_d2s_mat2pmat(nx, nu, nu, bs, S+jj*nx*nu, nx, hpQ[jj]+nu/bs*pnz*bs+nu%bs, pnz);
		cvt_d2s_mat2pmat(nx, nx, nu, bs, Q+jj*nx*nx, nx, hpQ[jj]+nu/bs*pnz*bs+nu%bs+nu*bs, pnz);
		for(ii = 0; ii<nu; ii++)
			hpQ[jj][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+ii*bs] = (float) r[ii+jj*nu];
		for(ii = 0; ii<nx; ii++)
			hpQ[jj][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+(nu+ii)*bs] = (float) q[ii+nx*jj];
		hpQ[jj][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+(nx+nu)*bs] = 1e35;
	}

	for(jj=0; jj<nu; jj++)
		for(ii=0; ii<nz; ii+=bs)
			for(i=0; i<bs; i++)
				hpQ[N][ii*pnz+i+jj*bs] = 0.0;
	for(jj=0; jj<nu; jj++)
		hpQ[N][jj/bs*pnz*bs+jj%bs+jj*bs] = 1.0;
	cvt_d2s_mat2pmat(nx, nx, nu, bs, Q, nx, hpQ[N]+nu/bs*pnz*bs+nu%bs+nu*bs, pnz);
	for(jj=0; jj<nx; jj++)
		hpQ[N][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+(nu+jj)*bs] = (float) q[jj];
	hpQ[N][(nx+nu)/bs*pnz*bs+(nx+nu)%bs+(nx+nu)*bs] = 1e35;
	
	// input constraints
	for(jj=0; jj<N; jj++)
	{
		for(ii=0; ii<nu; ii++)
		{
			hlb[jj][ii] = (float) lb[ii+nu*jj]; //if(hlb[jj][ii]<-1e2) hlb[jj][ii] = -1e2;
			hub[jj][ii] = (float) ub[ii+nu*jj]; //if(hub[jj][ii]>1e2) hub[jj][ii] = 1e2;
		}
	}

	// state constraints
	for(jj=0; jj<N; jj++)
	{
		for(ii=0; ii<nx; ii++)
		{
			hlb[jj+1][nu+ii] = (float) lb[N*nu+ii+nx*jj]; //if(hlb[jj+1][ii]<-1e2) hlb[jj+1][ii] = -1e2;
			hub[jj+1][nu+ii] = (float) ub[N*nu+ii+nx*jj]; //if(hub[jj+1][ii]>1e2) hub[jj+1][ii] = 1e2;
		}
	}

	// initial guess
	for (jj = 0; jj < N; jj++)
		for (ii = 0; ii < nu; ii++)
			hux[jj][ii] = (float) u[ii + nu * jj];

	for (jj = 0; jj <= N; jj++)
		for (ii = 0; ii < nx; ii++)
			hux[0][nu + ii] = (float) x[ii];

	// call the IP solver
#if IP == 1
		s_ip_box(nIt, k_max, tol, warm_start, sigma_par, stat, nx, nu, N, nb, hpBAbt, hpQ, hlb, hub, hux, compute_mult, hpi, hlam, ht, ptr, &info);
#else
		s_ip2_box(nIt, k_max, tol, warm_start, sigma_par, stat, nx, nu, N, nb, hpBAbt, hpQ, hlb, hub, hux, compute_mult, hpi, hlam, ht, ptr, &info);
#endif /* IP */

	if (info != 0)
		return 1;

	// copy back inputs and states
	for (jj = 0; jj < N; jj++)
		for (ii = 0; ii < nu; ii++)
			u[ii + nu * jj] = (double) hux[jj][ii];

	for (jj = 1; jj <= N; jj++)
		for (ii = 0; ii < nx; ii++)
			x[ii + nx * jj] = (double) hux[jj][nu + ii];

#else
#error "Impossible happened!"
#endif /* precision */

#if PC_DEBUG == 1
	for (jj = 0; jj < *nIt; jj++)
		printf("k = %d\tsigma = %f\talpha = %f\tmu = %f\t\tmu = %e\talpha = %f\tmu = %f\t\tmu = %e\n", jj,
			   stat[5*jj+0], stat[5*jj+1], stat[5*jj+2], stat[5*jj+2], stat[5*jj+3], stat[5*jj+4], stat[5*jj+4]);
	printf("\n");
#endif /* PC_DEBUG == 1 */

    return 0;
}
